# Inventory Management System

# Overview

The Inventory Management System is a web application developed using Django, Python, and deployed on Heroku. The purpose of this project is to provide an efficient solution for managing inventory, tracking stock levels, and ensuring that items are readily available when needed. It solves the problem of manual inventory tracking and helps businesses streamline their operations, saving time and reducing errors.

# UX Design Process

Link to User Stories in GitHub Projects:
[https://github.com/users/Hodoo08/projects/4]

# Wireframes:

[Attach or link to accessible wireframes used in the design process, ensuring high co]

# Design Rationale:

The layout and design choices were made with a focus on usability and accessibility. Key design decisions included a clean and simple interface, high contrast colors for readability, and a responsive design to ensure accessibility on various devices. Accessibility guidelines (e.g., WCAG) were integrated.
<<<<<<< HEAD
=======
I opted for a sandstone theme from bootswatch which is a simple theme with a touch of warmth that attracts users.
>>>>>>> refs/remotes/origin/main

# Reasoning For Any Final Changes:

During development, significant changes were made to enhance the user interface's inclusivity and accessibility. For example, adjustments were made to improve keyboard navigation and ensure all interactive elements are accessible to screen readers. These changes enhance the overall user experience.

# Key Features

Feature 1: View Inventory Items
Users can view a paginated list of inventory items, making it easy to navigate through large inventories.

Feature 2: Add Inventory Item
Inventory managers can add new items to the inventory, ensuring the system stays updated.

Feature 3: Edit Inventory Item
Inventory managers are able to edit already listed items, by changing and keeping up to date with the quantity of listed inventory items.

Feature 4: Delete Inventory Item
Users are able to delete inventory items via their disgression. Gives users the flexibilty to delete out of stock inventory. This adheres to one of CRUD functionality features.


# Deployment
Platform: Heroku

High-Level Deployment Steps:

Step 1: Set up a Heroku account and create a new app.
Step 2: Configure the Django application for Heroku deployment, including setting up the Procfile and necessary environment variables.
Step 3: Deploy the application using Git and Heroku CLI.

Verification and Validation:
Steps were taken to verify that the deployed version matches the development version in functionality. Additional checks were conducted to ensure the accessibility of the deployed application.

# Security Measures:

Environment variables are used for sensitive data.
DEBUG mode is disabled in production.
AI Implementation and Orchestration


# Code Creation: 
AI was used for rapid prototyping, with minor adjustments for alignment with project goals. Examples include using reverse prompts for alternative code solutions and question-answer prompts for resolving specific challenges.

# Debugging: 
AI tools were instrumental in resolving logic errors and enhancing maintainability, with a focus on simplifying complex logic to make it accessible. I was able to input error messages into co pilot and was able to pin point the error therefore resolving any issues swiftly.

# Performance and UX Optimization: 
AI-driven improvements were applied to enhance application speed and user experience for all users.
<<<<<<< HEAD

=======
>>>>>>> refs/remotes/origin/main
Automated Unit Testing: 
Adjustments were made to improve test coverage and ensure alignment with functionality. Prompts were used to generate inclusive test cases that considered edge cases for accessibility.

# Overall Impact:
AI tools streamlined repetitive tasks, enabling focus on high-level development. Efficiency gains included faster debugging, comprehensive testing, and improved code quality. Challenges included contextual adjustments to AI-generated outputs, which were resolved effectively, enhancing inclusivity.

# Testing Summary

# Manual Testing:


# Devices and Browsers Tested: 

The application was tested on various devices and browsers, ensuring testing was conducted with assistive technologies such as screen readers and keyboard-only navigation.

Features Tested: 
CRUD operations, navigation, and accessibility features were tested manually.
Results: All critical features worked as expected, including accessibility checks.
<<<<<<< HEAD

=======
>>>>>>> refs/remotes/origin/main

# Tools Used:

Django TestCase and other testing frameworks.
Features Covered: CRUD operations, authentication, and accessibility checks.

# Adjustments Made: 

Manual corrections were made to AI-generated test cases, particularly for accessibility.

# Future Enhancements:

Consider adding voice input capabilities for improved accessibility.
Implement additional language support to cater to a broader audience.
<<<<<<< HEAD
Add reporting features to provide more detailed insights into inventory trends.
=======
Add reporting features to provide more detailed insights into inventory trends.
>>>>>>> refs/remotes/origin/main
